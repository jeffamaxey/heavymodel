{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to DigitalActuary DigitalActuary is the home page for heavymodel , a python based actuarial modelling library. I have released heavymodel as open source software, for installation instructions and source code please see the installation page. I can also be contacted via: Twitter @lewisfogden LinkedIn linkedin.com/in/lewisfogden As heavymodel is currently in development, this documentation is incomplete in places, subject to change, and may have the occasional typo. Experimentation is encouraged, however please bear in mind the license conditions when using. What is heavymodel? heavymodel is a class-based library which enables Actuaries (and other modelling professionals) to build actuarial models in Python , using a function-based syntax similar to other actuarial modelling software, combined with the simplicity of writing code in python. It is intended for prototyping models, and also implementing them within wider software releases, for example web-based quote engines, capital models, and optimisation models. The core library places very few constraints on modellers, so is applicable to domains such as: product pricing deterministic valuations stochastic modelling nested models It requires no additional libraries so can be used with recent Python distributions on any platform (Windows, Linux, Cloud). Simple Example The following code is for a simple persistency model, with policies decreasing 10% each year. import pandas as pd import seaborn as sns sns.set() from heavymodel import Model class PersistencyModel(Model): def num_policies(self, t): if t == 0: return 1 else: return self.num_policies(t-1) - self.num_lapses(t-1) def num_lapses(self, t): return 0.1 * self.num_policies(t) model = PersistencyModel() model._run(20) df = pd.DataFrame({\"num_lapses\":model.num_lapses.values, \"num_policies\":model.num_policies.values}) sns.lineplot(data=df) This produces the following graph. For further details, please see the Getting Started section of the site.","title":"Home"},{"location":"#welcome-to-digitalactuary","text":"DigitalActuary is the home page for heavymodel , a python based actuarial modelling library. I have released heavymodel as open source software, for installation instructions and source code please see the installation page. I can also be contacted via: Twitter @lewisfogden LinkedIn linkedin.com/in/lewisfogden As heavymodel is currently in development, this documentation is incomplete in places, subject to change, and may have the occasional typo. Experimentation is encouraged, however please bear in mind the license conditions when using.","title":"Welcome to DigitalActuary"},{"location":"#what-is-heavymodel","text":"heavymodel is a class-based library which enables Actuaries (and other modelling professionals) to build actuarial models in Python , using a function-based syntax similar to other actuarial modelling software, combined with the simplicity of writing code in python. It is intended for prototyping models, and also implementing them within wider software releases, for example web-based quote engines, capital models, and optimisation models. The core library places very few constraints on modellers, so is applicable to domains such as: product pricing deterministic valuations stochastic modelling nested models It requires no additional libraries so can be used with recent Python distributions on any platform (Windows, Linux, Cloud).","title":"What is heavymodel?"},{"location":"#simple-example","text":"The following code is for a simple persistency model, with policies decreasing 10% each year. import pandas as pd import seaborn as sns sns.set() from heavymodel import Model class PersistencyModel(Model): def num_policies(self, t): if t == 0: return 1 else: return self.num_policies(t-1) - self.num_lapses(t-1) def num_lapses(self, t): return 0.1 * self.num_policies(t) model = PersistencyModel() model._run(20) df = pd.DataFrame({\"num_lapses\":model.num_lapses.values, \"num_policies\":model.num_policies.values}) sns.lineplot(data=df) This produces the following graph. For further details, please see the Getting Started section of the site.","title":"Simple Example"},{"location":"asset-modelling/","text":"Asset Modelling This section considers modelling of some investment assets (e.g. Unit-Linked funds) There are various ways to model portfolio of assets, we will look at three here: Nested unit models Individual asset functions Two parameter functions For brevity, all code is not written, but they provide an outline of the approach. Nested Model class Asset(Model): def value(self, t): if t == 0: return self.init_value else: return self.value(t-1) * (1 + self.inv_growth) class Portfolio(Model): def value(self, t): return sum(asset.value(t) for asset in self.assets) With this approach we initialise each Asset and pass these to Portfolio model. One of the benefits of this approach is that we can define different types of asset to have different functions, e.g. a Bond class could be defined which allows for the probability of default, as long as it implements the value(t) method it can be otherwise written as desired. my_assets = [Asset(init_value=100, inv_growth=0.04), Asset(init_value=200, inv_growth=0.02)] my_portfolio = Portfolio(assets = my_assets) print(my_portfolio.value(10)) Individual Asset Functions This approach may work well if there are only a few asset classes, the downside is that you need to replicate all the code for each asset class, and manually add them together. class Investment(Model): def fund_value_equity(self, t): pass # equity code here def fund_value_bond(self, t): pass # bond code here def value(self, t): return self.fund_value_bond(t) + self.fund_value_equity(t) Two Parameter (array) Functions This approach uses a two parameter asset_value function, the second parameter is the name of the asset. This is similar to modelling Income Protection business when recovery rates are likely to be a function of time and duration of sickness. class TPF_Portfolio(Model): def asset_value(self, t, asset_name): if t == 0: return self.init_asset_value[asset_name] else: return self.fund_value(self, t-1, asset_name) * (1 + ...) def value(self, t): return sum(asset_value(t, asset_name) for asset in self.asset_list) For this approach we need to specify initial values, in practice likely through an assumption file. assets = [\"equity\", \"bond\", \"property\"] init_values = {\"equity\": 1000, \"bond\": 500, \"property\": 400} model = TPF_Portfolio(init_asset_value = init_values, asset_list=assets)","title":"Asset Modelling"},{"location":"asset-modelling/#asset-modelling","text":"This section considers modelling of some investment assets (e.g. Unit-Linked funds) There are various ways to model portfolio of assets, we will look at three here: Nested unit models Individual asset functions Two parameter functions For brevity, all code is not written, but they provide an outline of the approach.","title":"Asset Modelling"},{"location":"asset-modelling/#nested-model","text":"class Asset(Model): def value(self, t): if t == 0: return self.init_value else: return self.value(t-1) * (1 + self.inv_growth) class Portfolio(Model): def value(self, t): return sum(asset.value(t) for asset in self.assets) With this approach we initialise each Asset and pass these to Portfolio model. One of the benefits of this approach is that we can define different types of asset to have different functions, e.g. a Bond class could be defined which allows for the probability of default, as long as it implements the value(t) method it can be otherwise written as desired. my_assets = [Asset(init_value=100, inv_growth=0.04), Asset(init_value=200, inv_growth=0.02)] my_portfolio = Portfolio(assets = my_assets) print(my_portfolio.value(10))","title":"Nested Model"},{"location":"asset-modelling/#individual-asset-functions","text":"This approach may work well if there are only a few asset classes, the downside is that you need to replicate all the code for each asset class, and manually add them together. class Investment(Model): def fund_value_equity(self, t): pass # equity code here def fund_value_bond(self, t): pass # bond code here def value(self, t): return self.fund_value_bond(t) + self.fund_value_equity(t)","title":"Individual Asset Functions"},{"location":"asset-modelling/#two-parameter-array-functions","text":"This approach uses a two parameter asset_value function, the second parameter is the name of the asset. This is similar to modelling Income Protection business when recovery rates are likely to be a function of time and duration of sickness. class TPF_Portfolio(Model): def asset_value(self, t, asset_name): if t == 0: return self.init_asset_value[asset_name] else: return self.fund_value(self, t-1, asset_name) * (1 + ...) def value(self, t): return sum(asset_value(t, asset_name) for asset in self.asset_list) For this approach we need to specify initial values, in practice likely through an assumption file. assets = [\"equity\", \"bond\", \"property\"] init_values = {\"equity\": 1000, \"bond\": 500, \"property\": 400} model = TPF_Portfolio(init_asset_value = init_values, asset_list=assets)","title":"Two Parameter (array) Functions"},{"location":"definitions/","text":"Definitions This page provides definitions of the core heavymodel functionality. Model methods: NOTE: User methods should not begin with an underscore ( _ ), as this is reserved for core functions. Any user method beginning with an underscore will be skipped when running the model (although still run if it is called by another function), and may inadvertently also conflict with core functions. initialisation ( __init__(*args, **kwargs) ): the default initialiser parses all supplied parameters and adds these to the namespace of the instance. _update(data_or_basis_item) : adds data or basis to the model space, so it can be referenced by attribute _clear_cache() : clears all results from an instance of the model _run(proj_len) : evaluates each single parameter function in the model from t = 0 to t = proj_len-1 _dataframe() : if pandas is installed, returns a dataframe of all results.","title":"Definitions"},{"location":"definitions/#definitions","text":"This page provides definitions of the core heavymodel functionality.","title":"Definitions"},{"location":"definitions/#model-methods","text":"NOTE: User methods should not begin with an underscore ( _ ), as this is reserved for core functions. Any user method beginning with an underscore will be skipped when running the model (although still run if it is called by another function), and may inadvertently also conflict with core functions. initialisation ( __init__(*args, **kwargs) ): the default initialiser parses all supplied parameters and adds these to the namespace of the instance. _update(data_or_basis_item) : adds data or basis to the model space, so it can be referenced by attribute _clear_cache() : clears all results from an instance of the model _run(proj_len) : evaluates each single parameter function in the model from t = 0 to t = proj_len-1 _dataframe() : if pandas is installed, returns a dataframe of all results.","title":"Model methods:"},{"location":"installation/","text":"Installation Note that heavymodel is currently in development Heavymodel is available from the Python Package Index (pypi.org): https://pypi.org/project/heavymodel-lewisfogden/ To install, use pip at the command line: pip install heavymodel-lewisfogden Source code is available on GitHub, along with examples: https://github.com/lewisfogden/heavymodel/ If you have any issues please raise an issue on GitHub.","title":"Installation"},{"location":"installation/#installation","text":"Note that heavymodel is currently in development Heavymodel is available from the Python Package Index (pypi.org): https://pypi.org/project/heavymodel-lewisfogden/ To install, use pip at the command line: pip install heavymodel-lewisfogden Source code is available on GitHub, along with examples: https://github.com/lewisfogden/heavymodel/ If you have any issues please raise an issue on GitHub.","title":"Installation"},{"location":"model-walkthrough/","text":"Model Walkthrough This section breaks down the individual segments of code within the example model outlined in the index. The overall model is: import pandas as pd import seaborn as sns sns.set() from heavymodel import Model class PersistencyModel(Model): def num_policies(self, t): if t == 0: return 1 else: return self.num_policies(t-1) - self.num_lapses(t-1) def num_lapses(self, t): return 0.1 * self.num_policies(t) model = PersistencyModel() model._run(20) df = pd.DataFrame({\"num_lapses\":model.num_lapses.values, \"num_policies\":model.num_policies.values}) sns.lineplot(data=df) Import libraries We first import required libraries. import pandas as pd import seaborn as sns sns.set() from heavymodel import Model pandas and seaborn are popular data and plotting libraries, for displaying the results. from heavymodel import Model makes the core Model class available. Define the class The user model is defined as a class, as follows: class PersistencyModel(Model): def num_policies(self, t): if t == 0: return 1 else: return self.num_policies(t-1) - self.num_lapses(t-1) def num_lapses(self, t): return 0.1 * self.num_policies(t) To make use of the functionality of heavymodel.Model , the user model inherits from this, as a sub-class. Functions ( num_policies , num_lapses ) are defined as methods in the class. Each of these returns a result depending on the value of t . Python methods take self as the first parameter, this refers to the instance of the class, when called, the self parameter is omitted, such as self.num_policies(t-1) . If a data item (attribute) such as age was added, the value of it could be accessed through self.age . For more information on python classes, see docs.python.org/3/tutorial/classes.html or other reputable tutorials. Run the model model = PersistencyModel() model._run(20) model = PersistencyModel() creates an instance of the model, with all the methods bound to it. For example, model.num_policies(50) would evaluate num_policies at t=50 (and all dependencies) and return the result. This allows models to be evaluated using the interactive prompt / REPL. model._run(20) evaluates all the functions in the model from t=0 to t=19 (i.e. 20 time periods). Results are stored in model.<method_name>.values , e.g. model.num_lapses.values . Extract and plot results df = pd.DataFrame({\"num_lapses\":model.num_lapses.values, \"num_policies\":model.num_policies.values}) sns.lineplot(data=df) This converts the results into a pandas dataframe, with column headers num_lapses and num_policies , and plots the result:","title":"Walkthrough"},{"location":"model-walkthrough/#model-walkthrough","text":"This section breaks down the individual segments of code within the example model outlined in the index. The overall model is: import pandas as pd import seaborn as sns sns.set() from heavymodel import Model class PersistencyModel(Model): def num_policies(self, t): if t == 0: return 1 else: return self.num_policies(t-1) - self.num_lapses(t-1) def num_lapses(self, t): return 0.1 * self.num_policies(t) model = PersistencyModel() model._run(20) df = pd.DataFrame({\"num_lapses\":model.num_lapses.values, \"num_policies\":model.num_policies.values}) sns.lineplot(data=df)","title":"Model Walkthrough"},{"location":"model-walkthrough/#import-libraries","text":"We first import required libraries. import pandas as pd import seaborn as sns sns.set() from heavymodel import Model pandas and seaborn are popular data and plotting libraries, for displaying the results. from heavymodel import Model makes the core Model class available.","title":"Import libraries"},{"location":"model-walkthrough/#define-the-class","text":"The user model is defined as a class, as follows: class PersistencyModel(Model): def num_policies(self, t): if t == 0: return 1 else: return self.num_policies(t-1) - self.num_lapses(t-1) def num_lapses(self, t): return 0.1 * self.num_policies(t) To make use of the functionality of heavymodel.Model , the user model inherits from this, as a sub-class. Functions ( num_policies , num_lapses ) are defined as methods in the class. Each of these returns a result depending on the value of t . Python methods take self as the first parameter, this refers to the instance of the class, when called, the self parameter is omitted, such as self.num_policies(t-1) . If a data item (attribute) such as age was added, the value of it could be accessed through self.age . For more information on python classes, see docs.python.org/3/tutorial/classes.html or other reputable tutorials.","title":"Define the class"},{"location":"model-walkthrough/#run-the-model","text":"model = PersistencyModel() model._run(20) model = PersistencyModel() creates an instance of the model, with all the methods bound to it. For example, model.num_policies(50) would evaluate num_policies at t=50 (and all dependencies) and return the result. This allows models to be evaluated using the interactive prompt / REPL. model._run(20) evaluates all the functions in the model from t=0 to t=19 (i.e. 20 time periods). Results are stored in model.<method_name>.values , e.g. model.num_lapses.values .","title":"Run the model"},{"location":"model-walkthrough/#extract-and-plot-results","text":"df = pd.DataFrame({\"num_lapses\":model.num_lapses.values, \"num_policies\":model.num_policies.values}) sns.lineplot(data=df) This converts the results into a pandas dataframe, with column headers num_lapses and num_policies , and plots the result:","title":"Extract and plot results"},{"location":"project-layout/","text":"Typical Project layout heavymodel places no constraints on how you set up a model, a typical structure is outlined below: run_model.py # The run file. heavymodel/ model.py # Key Code for model basis.py data.py ... # Other files models/ # Store user models here protection_model.py protection_pricing_basis.yaml tables/ uk_zero_spot.csv # Yield Curve qx_TFNL08.csv # Mortality Curve","title":"Project Layout"},{"location":"project-layout/#typical-project-layout","text":"heavymodel places no constraints on how you set up a model, a typical structure is outlined below: run_model.py # The run file. heavymodel/ model.py # Key Code for model basis.py data.py ... # Other files models/ # Store user models here protection_model.py protection_pricing_basis.yaml tables/ uk_zero_spot.csv # Yield Curve qx_TFNL08.csv # Mortality Curve","title":"Typical Project layout"},{"location":"pythonic-heavy-modelling/","text":"Pythonic Heavy Modelling Primary Motivation / Problem Statement Heavy models are models which are complex to compute, where values likely to be contingent; that is where the value at each timepoint t depends on the values at t-1 , t-2 etc. through to t=0 . This contingency can result in even a simple model causing stack overflows and other nastiness. Fortunately there are solutions, this document outlines one approach using the heavymodel library I have developed in Python. A trivial example is would be a value which starts at 1 at t=0 , and reduces by 5% at each subsequent time point. Without using the heavymodel library this could be written as: class DecreasingModel(): def var(self, t): if t==0: return 1 else: return self.var(t-1) * 0.95 This example could be run as follows: dm = DecreasingModel() results = {t:dm.var(t) for t in range(0, 11)} As expected, this gives results as follows: {0: 1, 1: 0.95, 2: 0.9025, ... 9: 0.6302494097246091, 10: 0.5987369392383786} As it is recursive dm.var(10) will be called once, dm.var(9) will be called twice, dm.var(0) called 11 times, in total 66 calls. For t=n , the total calls is n(n+1)/2 , i.e. O(n\u00b2); If we were to introduce multiple dependent functions the number of computations would grow exponentially. We can see the speed using the ipython magic function %timeit: In [6]: %timeit results = {t:dm.var(t) for t in range(0, 20)} 10000 loops, best of 3: 25.2 \u00b5s per loop In [7]: %timeit results = {t:dm.var(t) for t in range(0, 120)} 1000 loops, best of 3: 871 \u00b5s per loop To an actuary writing model and expecting execution similar to Excel, this can be a nasty surprise, and result in programming languages being rejected. To minimise run speed (and avoid recursion and stack overflows), we want to evaluate each function at most once. The solution can be achieved by inheriting from the Model class in the heavymodel library, which provides functionality to evaluate the user model. The example above can be rewritten as: from heavymodel import Model class DecreasingModel2(Model): def var(self, t): if t==0: return 1 else: return self.var(t-1) * 0.95 Model supplies a helper method _run which evaluates the model at each time point from t=0 to t=proj_length-1 (as python is zero-indexed): dm2 = DecreasingModel2() dm2._run(proj_length=11) results = dm2.var.values # results are stored in the .values attribute Results are identical to the first case: {0: 1, 1: 0.95, 2: 0.9025, ... 9: 0.6302494097246091, 10: 0.5987369392383786} Timings are outlined in the section below. Aside: The _run method is provided by the heavymodel.Model class, which is inherited by the user model class. It's implementation may vary but its purpose is to calculate each single argument user method starting from t=0 up to proj_length-1 . Speed comparison of the two methods Timing dm2._run() is complicated by the fact that after the first run, results are stored for that instance. To provide a like-for-like comparison we need to create a new instance of the model for each evaluation: def dm_time(proj_len): dm = DecreasingModel() results = {t:dm.var(t) for t in range(0, proj_len)} return results def dm2_time(proj_len): dm2 = DecreasingModel2() dm2._run(proj_len) return dm2.var.values Using %timeit over a series of values of proj_len allows us to measure the relative speeds, for example for proj_len=70 . In [72]: %timeit dm_time(70) 1000 loops, best of 3: 284 \u00b5s per loop In [73]: %timeit dm2_time(70) 10000 loops, best of 3: 99.7 \u00b5s per loop A log-log plot of results is below. We can see that dm2 (the model using heavymodel.Model ) has an increased initialisation time, but for projection lengths greater than 50(ish), dm2 becomes substantially quicker. At proj_len equal to 1280 and 2560, dm failed due to a RecursionError. Given that most heavy models are likely to be run monthly for at least 20 years, a typical proj_len will be 240 or greater, and so the heavymodel approach should give substantial speed benefits. If you are interested in other approaches, I recommend the OpenActuarial site .","title":"Rationale"},{"location":"pythonic-heavy-modelling/#pythonic-heavy-modelling","text":"","title":"Pythonic Heavy Modelling"},{"location":"pythonic-heavy-modelling/#primary-motivation-problem-statement","text":"Heavy models are models which are complex to compute, where values likely to be contingent; that is where the value at each timepoint t depends on the values at t-1 , t-2 etc. through to t=0 . This contingency can result in even a simple model causing stack overflows and other nastiness. Fortunately there are solutions, this document outlines one approach using the heavymodel library I have developed in Python. A trivial example is would be a value which starts at 1 at t=0 , and reduces by 5% at each subsequent time point. Without using the heavymodel library this could be written as: class DecreasingModel(): def var(self, t): if t==0: return 1 else: return self.var(t-1) * 0.95 This example could be run as follows: dm = DecreasingModel() results = {t:dm.var(t) for t in range(0, 11)} As expected, this gives results as follows: {0: 1, 1: 0.95, 2: 0.9025, ... 9: 0.6302494097246091, 10: 0.5987369392383786} As it is recursive dm.var(10) will be called once, dm.var(9) will be called twice, dm.var(0) called 11 times, in total 66 calls. For t=n , the total calls is n(n+1)/2 , i.e. O(n\u00b2); If we were to introduce multiple dependent functions the number of computations would grow exponentially. We can see the speed using the ipython magic function %timeit: In [6]: %timeit results = {t:dm.var(t) for t in range(0, 20)} 10000 loops, best of 3: 25.2 \u00b5s per loop In [7]: %timeit results = {t:dm.var(t) for t in range(0, 120)} 1000 loops, best of 3: 871 \u00b5s per loop To an actuary writing model and expecting execution similar to Excel, this can be a nasty surprise, and result in programming languages being rejected. To minimise run speed (and avoid recursion and stack overflows), we want to evaluate each function at most once. The solution can be achieved by inheriting from the Model class in the heavymodel library, which provides functionality to evaluate the user model. The example above can be rewritten as: from heavymodel import Model class DecreasingModel2(Model): def var(self, t): if t==0: return 1 else: return self.var(t-1) * 0.95 Model supplies a helper method _run which evaluates the model at each time point from t=0 to t=proj_length-1 (as python is zero-indexed): dm2 = DecreasingModel2() dm2._run(proj_length=11) results = dm2.var.values # results are stored in the .values attribute Results are identical to the first case: {0: 1, 1: 0.95, 2: 0.9025, ... 9: 0.6302494097246091, 10: 0.5987369392383786} Timings are outlined in the section below. Aside: The _run method is provided by the heavymodel.Model class, which is inherited by the user model class. It's implementation may vary but its purpose is to calculate each single argument user method starting from t=0 up to proj_length-1 .","title":"Primary Motivation / Problem Statement"},{"location":"pythonic-heavy-modelling/#speed-comparison-of-the-two-methods","text":"Timing dm2._run() is complicated by the fact that after the first run, results are stored for that instance. To provide a like-for-like comparison we need to create a new instance of the model for each evaluation: def dm_time(proj_len): dm = DecreasingModel() results = {t:dm.var(t) for t in range(0, proj_len)} return results def dm2_time(proj_len): dm2 = DecreasingModel2() dm2._run(proj_len) return dm2.var.values Using %timeit over a series of values of proj_len allows us to measure the relative speeds, for example for proj_len=70 . In [72]: %timeit dm_time(70) 1000 loops, best of 3: 284 \u00b5s per loop In [73]: %timeit dm2_time(70) 10000 loops, best of 3: 99.7 \u00b5s per loop A log-log plot of results is below. We can see that dm2 (the model using heavymodel.Model ) has an increased initialisation time, but for projection lengths greater than 50(ish), dm2 becomes substantially quicker. At proj_len equal to 1280 and 2560, dm failed due to a RecursionError. Given that most heavy models are likely to be run monthly for at least 20 years, a typical proj_len will be 240 or greater, and so the heavymodel approach should give substantial speed benefits. If you are interested in other approaches, I recommend the OpenActuarial site .","title":"Speed comparison of the two methods"},{"location":"stochastic-modelling/","text":"Stochastic Modelling The below code generates 1000 simulations over a 60 year period for an asset which has returns normally distributed with mean 0.04 and standard deviation 0.06. This produces a density plot as follows: from heavymodel import Model, Data import random import pandas as pd import seaborn as sns sns.set() rng = random.Random(0) # seed set to ensure replicable. class Asset(Model): def asset_value(self, t): if t == 0: return self.initial_fund else: return self.asset_value(t-1) * (1 + self.inv_growth(t)) def inv_growth(self, t): return rng.normalvariate(self.mu, self.sigma) data = Data(dict(mu=0.04, sigma=0.06, initial_fund=1000)) simulations = 1000 results = [] for count, sim in enumerate(range(simulations)): asset = Asset(data=data) asset._run(61) results.append(asset.asset_value(60)) result_df = pd.DataFrame(data={\"asset_value\":results}) sns.kdeplot(result_df[\"asset_value\"])","title":"Stochastic Modelling"},{"location":"stochastic-modelling/#stochastic-modelling","text":"The below code generates 1000 simulations over a 60 year period for an asset which has returns normally distributed with mean 0.04 and standard deviation 0.06. This produces a density plot as follows: from heavymodel import Model, Data import random import pandas as pd import seaborn as sns sns.set() rng = random.Random(0) # seed set to ensure replicable. class Asset(Model): def asset_value(self, t): if t == 0: return self.initial_fund else: return self.asset_value(t-1) * (1 + self.inv_growth(t)) def inv_growth(self, t): return rng.normalvariate(self.mu, self.sigma) data = Data(dict(mu=0.04, sigma=0.06, initial_fund=1000)) simulations = 1000 results = [] for count, sim in enumerate(range(simulations)): asset = Asset(data=data) asset._run(61) results.append(asset.asset_value(60)) result_df = pd.DataFrame(data={\"asset_value\":results}) sns.kdeplot(result_df[\"asset_value\"])","title":"Stochastic Modelling"},{"location":"typed-csv-specification/","text":"Typed CSV Specification Rationale The purpose of the typed csv specification is to build on the common csv (comma separated value) specification with a standard unambigious format. The key issues with most csv files at present are: Character encodings are not defined The data has no type attributes, so 1 could be considered an integer, floating point number, or a string. File loaders often have to guess the type, and modelling software needs to be written to explicitly cast types. Example An example of typed csv: # comment lines @ author: name@domain.com @ write_date: 2020_03_50 !,time,score,word,is_first,price,start_date,start_time ?,int,float,str,bool,dec,yyyy_mm_dd,hh_mm_ss *,1,1.23,hello,Y,2.52,2020_03_28,14_20_40 Key Rules Typed CSV files are always encoded as UTF-8. All header names, header types and data rows must have the same length. The first character in the line determines the purpose of the line. The first character must be followed by a comma if it is ! , ? or * . the separator defaults to comma , . @ can have a space between it and the metadata key. All meta data must be above the header row Rows must be in the following order: meta > header > types > data Comments can be placed anywhere and will be ignored Rows must end with a new line character \\n Character Purpose Notes # comment ignored @ metadata for storing individual values, key and value are separated by a colon : ! header names of the columns in the data ? data types the type of data in the column * data row a row of data values Data Types int : Integer (..., -3, -2, -1, 0, 1, 2, 3, ...) float : Floating Point Number (13523.524), only decimal notation is supported str : String/Text bool : Boolean, using the following (case insensitive) T , 1 , Y , true evaluate to True F , 0 , N , false , evaluate to False dec : Decimal for dealing with currency yyyy_mm_dd : date hh_mm_ss : time u_ : a user defined type Data for number types ( int , float , dec ) can optionally have underscore characters ( _ ) as thousand separators. These will be ignored on processing. Metadata A single whitespace can be added before the @ . Thus the following are valid metadata and mean the same. Any trailing whitespace will be considered part of the key. Any characters after the colon ( : ) will be considered part of the value, up until the new line. The type of the value is not documented. @key:value @ key:value Reserved keys Reserved keys are optional, but can enhance the stability of the data @length : The number of rows of data, as an integer, if this is supplied and the values does not match the number of data rows, an error will occur. @separator : The separator character(s) @md5-checksum : An 128bit MD5 checksum, presented as 32 hexadecimal digits (0-9a-f), this hash is based on a string containing header, types and data in the order they appear. Metadata and comments are ignored. See https://en.wikipedia.org/wiki/MD5 for details of MD5. Custom Separator If the data is likely to contain commas, a custom separator can be specified by @separator metadata item. The separator can consist of one or more characters. @separator:^|^ Application specific types A type beginning with u_ is left to the application to process. An example would be u_yyyy_mm which would store the year and month. Caution should be taken to avoid name conflicts.","title":"Typed CSV"},{"location":"typed-csv-specification/#typed-csv-specification","text":"","title":"Typed CSV Specification"},{"location":"typed-csv-specification/#rationale","text":"The purpose of the typed csv specification is to build on the common csv (comma separated value) specification with a standard unambigious format. The key issues with most csv files at present are: Character encodings are not defined The data has no type attributes, so 1 could be considered an integer, floating point number, or a string. File loaders often have to guess the type, and modelling software needs to be written to explicitly cast types.","title":"Rationale"},{"location":"typed-csv-specification/#example","text":"An example of typed csv: # comment lines @ author: name@domain.com @ write_date: 2020_03_50 !,time,score,word,is_first,price,start_date,start_time ?,int,float,str,bool,dec,yyyy_mm_dd,hh_mm_ss *,1,1.23,hello,Y,2.52,2020_03_28,14_20_40","title":"Example"},{"location":"typed-csv-specification/#key-rules","text":"Typed CSV files are always encoded as UTF-8. All header names, header types and data rows must have the same length. The first character in the line determines the purpose of the line. The first character must be followed by a comma if it is ! , ? or * . the separator defaults to comma , . @ can have a space between it and the metadata key. All meta data must be above the header row Rows must be in the following order: meta > header > types > data Comments can be placed anywhere and will be ignored Rows must end with a new line character \\n Character Purpose Notes # comment ignored @ metadata for storing individual values, key and value are separated by a colon : ! header names of the columns in the data ? data types the type of data in the column * data row a row of data values","title":"Key Rules"},{"location":"typed-csv-specification/#data-types","text":"int : Integer (..., -3, -2, -1, 0, 1, 2, 3, ...) float : Floating Point Number (13523.524), only decimal notation is supported str : String/Text bool : Boolean, using the following (case insensitive) T , 1 , Y , true evaluate to True F , 0 , N , false , evaluate to False dec : Decimal for dealing with currency yyyy_mm_dd : date hh_mm_ss : time u_ : a user defined type Data for number types ( int , float , dec ) can optionally have underscore characters ( _ ) as thousand separators. These will be ignored on processing.","title":"Data Types"},{"location":"typed-csv-specification/#metadata","text":"A single whitespace can be added before the @ . Thus the following are valid metadata and mean the same. Any trailing whitespace will be considered part of the key. Any characters after the colon ( : ) will be considered part of the value, up until the new line. The type of the value is not documented. @key:value @ key:value","title":"Metadata"},{"location":"typed-csv-specification/#reserved-keys","text":"Reserved keys are optional, but can enhance the stability of the data @length : The number of rows of data, as an integer, if this is supplied and the values does not match the number of data rows, an error will occur. @separator : The separator character(s) @md5-checksum : An 128bit MD5 checksum, presented as 32 hexadecimal digits (0-9a-f), this hash is based on a string containing header, types and data in the order they appear. Metadata and comments are ignored. See https://en.wikipedia.org/wiki/MD5 for details of MD5.","title":"Reserved keys"},{"location":"typed-csv-specification/#custom-separator","text":"If the data is likely to contain commas, a custom separator can be specified by @separator metadata item. The separator can consist of one or more characters. @separator:^|^","title":"Custom Separator"},{"location":"typed-csv-specification/#application-specific-types","text":"A type beginning with u_ is left to the application to process. An example would be u_yyyy_mm which would store the year and month. Caution should be taken to avoid name conflicts.","title":"Application specific types"}]}